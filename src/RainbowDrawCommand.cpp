/**
 *  @file   RainbowDrawCommand.cpp
 *  @brief  Implementation of RainbowDrawCommand.hpp.
 *  @author John
 *  @date   2020-04-14
 ***********************************************/
#ifndef RAINBOWDRAWCOMMAND_CPP
#define RAINBOWDRAWCOMMAND_CPP

 // Include our Third-Party SFML header
#include <SFML/Graphics/Color.hpp>
// Include standard library C++ libraries.
#include <iostream>
#include <cstring>
// Project header files
#include "App.hpp"
#include "RainbowDrawCommand.hpp"


/*! \brief Shift the given color towards the toColor by one step
 *	<p> Function inspired by https://gist.github.com/zachflower/79df9ed5ca398264d3b6,
 *      since this project was getting long in the tooth but also i really do want 
 *      the line to be a rainbow and not just one color.
 *
 * @return True, if the color matches.
 *
 */
bool RainbowDrawCommand::colorStep(sf::Color* color, const sf::Color* toColor) {
    if (color->r != toColor->r || color->g != toColor->g || color->b != toColor->b) {
        if (color->r < toColor->r) color->r += 1;
        if (color->r > toColor->r) color->r -= 1;

        if (color->g < toColor->g) color->g += 1;
        if (color->g > toColor->g) color->g -= 1;

        if (color->b < toColor->b) color->b += 1;
        if (color->b > toColor->b) color->b -= 1;

        return false;
    }
    return true;
}

/*! \brief Draw a line along user mouse inputs that is rainbow colored.
 *	<p> Function inspired by https://gist.github.com/zachflower/79df9ed5ca398264d3b6,
 *      since this project was getting long in the tooth but also i really do want
 *      the line to be a rainbow and not just one color.
 *
 * @return True, if the color matches.
 *
 */
bool RainbowDrawCommand::cycleDrawableColor() {
    assert(shadow->drawable->size() == 2);

    // do the rainbow thing!
    sf::VertexArray* point = shadow->drawable->at(0);
    sf::VertexArray* line = shadow->drawable->at(1);

    bool returnFlag = true;
    returnFlag = colorStep(&point[0][0].color, &toColor) && returnFlag;
    returnFlag = colorStep(&point[0][0].color, &toColor) && returnFlag;
    returnFlag = colorStep(&point[0][0].color, &toColor) && returnFlag;
    returnFlag = colorStep(&point[0][0].color, &toColor) && returnFlag;
    for (int i = 0; i < line->getVertexCount(); i++) {
        returnFlag = colorStep(&line[0][i].color, &toColor) && returnFlag;
        returnFlag = colorStep(&line[0][i].color, &toColor) && returnFlag;
        returnFlag = colorStep(&line[0][i].color, &toColor) && returnFlag;
        returnFlag = colorStep(&line[0][i].color, &toColor) && returnFlag;
    }
    return returnFlag;
}

/*! \brief Draw a line along user mouse inputs that is rainbow colored.
 *	<p> If the command has not been performed, start a new line of
 *		the application's current color at the current mouse position.
 *		The command will then become <code>active</code>.
 *		Subsequent calls will draw the line along new mouse positions.
 *	<p>	If the command is called after it has been terminated (i.e. when it
 *		has been placed in the undo stack, after the user releases their click)
 *		it will call terminate, which will push the previously created
 *		line to the application.
 *  <p> It will also then push and execute a new instance of RainbowDrawCommand,
 *      which will always register as active; this instance will adjust the colors of 
 *     it's parent every update. It can be terminated by its parent if its parent's 
 *      undo is called, and regenerated by its parent if its parent's redo is called.
 *	<p>	This command cannot be undone until this function is called and
 *		subsequently terminated.
 *
 * @return True, if the command is successfully run.
 *
 */
bool RainbowDrawCommand::silent_execute() {
    //if this is a support command, it behaves differently than a normal draw command!
    if (supportCommand) {
        assert(shadow);
        if (!shadow->drawable) {
            return true;
        }
        switch(tgtColor) {
        case RED:
            if (cycleDrawableColor()) {
                tgtColor = YELLOW;
                toColor = sf::Color::Yellow;
            }
            return false;
        case YELLOW:
            if (cycleDrawableColor()) {
                tgtColor = GREEN;
                toColor = sf::Color::Green;
            }
            return false;
        case GREEN:
            if (cycleDrawableColor()) {
                tgtColor = BLUE;
                toColor = sf::Color::Blue;
            }
            return false;
        case BLUE:
            if (cycleDrawableColor()) {
                tgtColor = PURPLE;
                toColor = sf::Color::Magenta;
            }
            return false;
        case PURPLE:
            if (cycleDrawableColor()) {
                tgtColor = RED;
                toColor = sf::Color::Red;
            }
            return false;
        }
        assert(false); // == "Reached end of color loop incorrectly.");
    }
    else {
        this->DrawCommand::silent_execute();
        if (!isActive() && !shadow) {
            terminate();
        }
    }
	return true;
}

/*! \brief Remove the line from the application.
 *	<p>	If execute() followed by terminate() has not been called,
 *		this command cannot be undone (returns false).
 *
 * @return True, if the command is successfully undone.
 *
 */
bool RainbowDrawCommand::silent_undo() {
	if (!undoAble) return false;
	// remove drawings from back of pictures.
	for (int i = 0; i < drawable->size(); i++) {
		app->getUserPictures().pop_back();
	}
    // terminate shadow; it will be cleaned on the next iteration
    shadow->active = false;
    shadow->shadow = nullptr;
    shadow = nullptr;
	return true;
}


/*! \brief Stop drawing the line, then push the line to the main application.
 * <p> If execute has not been called, this command dset redoAble and undoAble
 *		to false.
 *
 */
void RainbowDrawCommand::terminate() {
    this->DrawCommand::terminate();
    if (supportCommand && shadow) {
        active = true;

#ifdef _DEBUG
        std::cout << "Refusing to cancel " << get_m_commandDescription() << "; can only be culled by parent.\n";
#endif
        return;
    }
    else {
        if (!shadow) {
            app->AddCommand(getShadow());
            app->ExecuteCommand();
        }
    }
}

/*! \brief  This function is a to string method to be passed to network
 *
 * @return A C string of this Command
 */
const char* RainbowDrawCommand::parseOut() {
    if (supportCommand) {
        // shadow commands do not get sent
        return "";
    }

	std::string builder = "8 " + std::string(Command::parseOut());
	char* cstr = new char[builder.length() + 1];
	std::strcpy(cstr, builder.c_str());
	return cstr;
};

/** \brief Adjust this command's fields to match the given input.
	e.g. parseIn = "0Generic Command Description\n000\0"
	e.g. parseIn = "0Generic Command Description\n000,50,50,255,255,255;25,25,255,255,255...."
 * @param [in] commandDescription The command as a parsed string.
 **/
RainbowDrawCommand* RainbowDrawCommand::parseIn(std::string input) {
	// remaining input must be of generic command
	Command::parseIn(input);
    active = false;
    assert(drawable);
    assert(isRedoAble());
	return this;
};

RainbowDrawCommand* RainbowDrawCommand::getShadow() {
    if (!shadow) {
        shadow = new RainbowDrawCommand(app, "shadow_");
        shadow->active = true;
        shadow->supportCommand = true;
        shadow->shadow = this;
    }
    return shadow;
}

#endif
